import React, { useState, useRef, useEffect, useCallback } from 'react';

// Import custom hooks and components from their new feature-based paths
import useCanvas from './hooks/useCanvas'; // Generic canvas setup hook
import useDrawing from './features/drawing/useDrawing'; // Drawing feature hook
import useHistory from './features/history/useHistory'; // History feature hook
import useImageProcessing from './features/imageProcessing/useImageProcessing'; // Image processing feature hook
import AppLayout from './components/AppLayout'; // Main layout component

// Import canvas utility functions (path corrected)
import { clearCanvas, drawImageOnCanvas } from './features/drawing/canvasUtils';

// Helper function to convert RGBA to HEX (for color input type)
function rgbaToHex(rgba) {
    if (!rgba || rgba.startsWith('#')) return rgba; // Already hex or invalid
    const parts = rgba.match(/\d+/g);
    if (!parts || parts.length < 3) return '#000000'; // Default black if invalid

    const r = parseInt(parts[0]);
    const g = parseInt(parts[1]);
    const b = parseInt(parts[2]);

    const toHex = (c) => {
        const hex = c.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    };

    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}

function App() {
    // Canvas Refs
    const originalCanvasRef = useRef(null);
    const drawingOverlayCanvasRef = useRef(null); // NEW: Ref for the drawing overlay
    const maskCanvasRef = useRef(null);
    const outputCanvasRef = useRef(null); // Hidden canvas for off-screen processing

    // --- Core Application State (managed directly in App.js - moved to top) ---
    // These must be declared before any hooks that consume them.
    const [shapes, setShapes] = useState([]); // Array to store all drawn shapes
    const [colorPickedMaskDataUrl, setColorPickedMaskDataUrl] = useState(null); // Data URL of the mask generated by color selection
    const [freeShapePoints, setFreeShapePoints] = useState([]); // Points for the current free shape being drawn
    const [selectedShapeId, setSelectedShapeId] = useState(null); // ID of the currently selected shape for editing


    // State for image source and canvas readiness
    const [originalImageSrc, setOriginalImageSrc] = useState(null);
    const [isOriginalCanvasReadyForPixels, setIsOriginalCanvasReadyForPixels] = useState(false);

    // Drawing States
    const [drawingMode, setDrawingMode] = useState('brush'); // 'brush', 'rectangle', 'circle', 'triangle', 'free_shape', 'color_select', 'edit_shape'
    const [penSize, setPenSize] = useState(5);
    const [penColor, setPenColor] = useState('#FF0000'); // Default to red for outlines
    const [selectedColor, setSelectedColor] = useState(null); // RGBA string of the color picked for matching
    const [colorTolerance, setColorTolerance] = useState(30); // Tolerance for color matching
    const [imageTypeDescription, setImageTypeDescription] = useState(''); // For AI context

    // Image Processing States
    const [repairedImageSrc, setRepairedImageSrc] = useState(null);
    const [showMaskOnSecondCanvas, setShowMaskOnSecondCanvas] = useState(true); // True to show mask, false to show repaired
    const [repairMethod, setRepairMethod] = useState('telea'); // Default AI repair method

    // Loading states for various processes
    const [isImageProcessingLoading, setIsImageProcessingLoading] = useState(false);
    const [isDrawingLoading, setIsDrawingLoading] = useState(false); // For color match operations

    // History management refs
    const isRestoringHistoryRef = useRef(false); // Flag to prevent saving state during undo/redo
    // shouldSaveHistoryRef is now used as a signal *within* action handlers, not as a useEffect dependency trigger
    const shouldSaveHistoryRef = useRef(false);


    // Combine all loading states
    const totalLoading = isImageProcessingLoading || isDrawingLoading;

    // --- Custom Hooks ---

    // useHistory hook now consumes 'shapes' and 'setShapes' from App.js
    const {
        undo,
        redo,
        reset,
        canUndo,
        canRedo,
        saveState, // saveState is now passed as a function to be called explicitly
    } = useHistory(
        originalImageSrc,
        setShapes,
        setColorPickedMaskDataUrl,
        maskCanvasRef,
        isRestoringHistoryRef,
        // activeDisplayMaskSrc is derived from shapes in useDrawing, so it's not directly passed here
        // useHistory will read the mask from the canvas if needed for redraw
    );

    const { canvasWidth, canvasHeight } = useCanvas(
        originalCanvasRef,
        maskCanvasRef,
        outputCanvasRef,
        originalImageSrc,
        setIsOriginalCanvasReadyForPixels
    );

    const {
        activeDisplayMaskSrc,
        closeFreeShape,
        handleMouseDown,
        handleMouseMove,
        handleMouseUp,
        handleMouseLeave,
        handleDoubleClick,
        handleContiguousColorMatch,
        handleGlobalColorMatch,
        selectedColorRgbString,
    } = useDrawing(
        originalCanvasRef,
        drawingOverlayCanvasRef, // Pass the new overlay ref
        maskCanvasRef,
        outputCanvasRef,
        drawingMode,
        penSize,
        penColor,
        originalImageSrc,
        selectedColor,
        setSelectedColor,
        colorTolerance,
        shapes, // Pass shapes from App.js state
        setShapes, // Pass setShapes from App.js state
        freeShapePoints, // Pass freeShapePoints from App.js state
        setFreeShapePoints, // Pass setFreeShapePoints from App.js state
        selectedShapeId, // Pass selectedShapeId from App.js state
        setSelectedShapeId, // Pass setSelectedShapeId from App.js state
        isRestoringHistoryRef,
        shouldSaveHistoryRef, // Pass shouldSaveHistoryRef for explicit signaling
        setIsDrawingLoading, // Pass setter for drawing loading state
        totalLoading, // Pass totalLoading to useDrawing
        isOriginalCanvasReadyForPixels // <--- ADDED THIS LINE
    );

    const {
        repairedImageSrc: imageProcessingRepairedImageSrc, // Rename to avoid conflict
        setRepairedImageSrc: setImageProcessingRepairedImageSrc, // Rename to avoid conflict
        showMaskOnSecondCanvas: imageProcessingShowMaskOnSecondCanvas, // Rename to avoid conflict
        setShowMaskOnSecondCanvas: setImageProcessingShowMaskOnSecondCanvas, // Rename to avoid conflict
        detectCorruption,
        detectCorruptionFromMask,
        repairPixels,
        onGenerateKeywords,
    } = useImageProcessing(
        originalImageSrc,
        activeDisplayMaskSrc,
        setColorPickedMaskDataUrl, // This setter now belongs to App.js
        setShapes, // This setter now belongs to App.js
        originalCanvasRef,
        shouldSaveHistoryRef, // Pass shouldSaveHistoryRef for explicit signaling
        setIsImageProcessingLoading // Pass setter for image processing loading state
    );

    // Sync repairedImageSrc and showMaskOnSecondCanvas from useImageProcessing
    useEffect(() => {
        setRepairedImageSrc(imageProcessingRepairedImageSrc);
    }, [imageProcessingRepairedImageSrc]);

    useEffect(() => {
        setShowMaskOnSecondCanvas(imageProcessingShowMaskOnSecondCanvas);
    }, [imageProcessingShowMaskOnSecondCanvas]);


    // --- Effects & Handlers ---

    // Effect to draw the mask or repaired image on the second canvas
    // This is the crucial useEffect you provided!
    useEffect(() => {
        const canvas = maskCanvasRef.current;
        const ctx = canvas?.getContext('2d');
        if (!ctx || !canvas) return;

        // Clear previous content
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const img = new Image();

        if (showMaskOnSecondCanvas && activeDisplayMaskSrc) {
            img.src = activeDisplayMaskSrc;
            img.onload = () => {
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            };
            img.onerror = () => {
                console.error("Failed to load activeDisplayMaskSrc for maskCanvas.");
            };
        } else if (!showMaskOnSecondCanvas && repairedImageSrc) {
            img.src = repairedImageSrc;
            img.onload = () => {
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            };
            img.onerror = () => {
                console.error("Failed to load repairedImageSrc for maskCanvas.");
            };
        }
    }, [showMaskOnSecondCanvas, activeDisplayMaskSrc, repairedImageSrc, maskCanvasRef]);


    // Initial save of empty state when component mounts
    useEffect(() => {
        // This useEffect will run once on mount to save the initial empty state.
        // It directly calls saveState with the current (empty) shapes and mask.
        saveState(shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc);
    }, []); // Empty dependency array means it runs once on mount


    // Handle image upload
    const handleImageUpload = useCallback((event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                setOriginalImageSrc(e.target.result);
                setRepairedImageSrc(null); // Clear any previous repaired image
                setColorPickedMaskDataUrl(null); // Clear any color-picked mask
                setShapes([]); // Clear all shapes
                setFreeShapePoints([]); // Clear free shape points
                setSelectedShapeId(null); // Clear selected shape ID
                setShowMaskOnSecondCanvas(true); // Default to showing mask view

                // After all state updates are batched, save the new state to history
                // We use a timeout to ensure the state updates have propagated
                setTimeout(() => {
                    saveState([], null, null); // Save the cleared state explicitly
                }, 0);
            };
            reader.readAsDataURL(file);
        }
    }, [setOriginalImageSrc, setRepairedImageSrc, setColorPickedMaskDataUrl, setShapes, setFreeShapePoints, setSelectedShapeId, setShowMaskOnSecondCanvas, saveState]);


    // Handle image download
    const handleDownload = useCallback((format) => {
        const canvasToDownload = showMaskOnSecondCanvas ? maskCanvasRef.current : originalCanvasRef.current;
        if (!canvasToDownload || (!repairedImageSrc && !activeDisplayMaskSrc)) {
            console.error("No image or mask to download.");
            return;
        }

        let finalImageSrc = null;
        if (showMaskOnSecondCanvas && activeDisplayMaskSrc) {
            finalImageSrc = activeDisplayMaskSrc;
        } else if (!showMaskOnSecondCanvas && repairedImageSrc) {
            finalImageSrc = repairedImageSrc;
        } else {
            console.error("No valid image source for download.");
            return;
        }

        const link = document.createElement('a');
        link.download = `image-repair-ai-${Date.now()}.${format}`;

        // Create a temporary canvas to draw the image at its actual dimensions
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');

        const img = new Image();
        img.onload = () => {
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            tempCtx.drawImage(img, 0, 0);

            if (format === 'png') {
                link.href = tempCanvas.toDataURL('image/png');
            } else if (format === 'jpeg') {
                link.href = tempCanvas.toDataURL('image/jpeg', 0.9); // 0.9 quality for JPEG
            }
            link.click();
        };
        img.onerror = () => {
            console.error("Failed to load image for download.");
        };
        img.src = finalImageSrc;

    }, [activeDisplayMaskSrc, repairedImageSrc, showMaskOnSecondCanvas]);


    // Props to pass to AppLayout (which now acts as the main UI container)
    const appLayoutProps = {
        originalCanvasRef,
        drawingOverlayCanvasRef,
        maskCanvasRef,
        outputCanvasRef,
        canvasWidth,
        canvasHeight,
        originalImageSrc,
        activeDisplayMaskSrc,
        repairedImageSrc,
        showMaskOnSecondCanvas,
        setShowMaskOnSecondCanvas,
        undo: useCallback(() => undo(shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc), [undo, shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc]),
        redo: useCallback(() => redo(shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc), [redo, shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc]),
        reset: useCallback(() => reset(shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc), [reset, shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc]),
        canUndo,
        canRedo,
        handleDownload,
        // Pass a wrapper to ensure saveState is called after drawing actions complete
        handleMouseDown: useCallback((e) => handleMouseDown(e), [handleMouseDown]),
        handleMouseMove: useCallback((e) => handleMouseMove(e), [handleMouseMove]),
        handleMouseUp: useCallback((e) => {
            handleMouseUp(e);
            // After handleMouseUp potentially updates shapes, save the state
            // Use a timeout to ensure state updates are batched and propagated
            setTimeout(() => {
                saveState(shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc);
            }, 0);
        }, [handleMouseUp, saveState, shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc]),
        handleMouseLeave: useCallback((e) => handleMouseLeave(e), [handleMouseLeave]),
        handleDoubleClick: useCallback((e) => handleDoubleClick(e), [handleDoubleClick]),
        totalLoading,
        controlPanelProps: {
            isLoading: totalLoading, // Pass combined loading state
            isOriginalCanvasReadyForPixels,
            handleImageUpload,
            drawingMode,
            setDrawingMode,
            penSize,
            setPenSize,
            penColor: rgbaToHex(penColor), // Convert RGBA to HEX for color input
            freeShapePoints,
            closeFreeShape: useCallback(() => {
                closeFreeShape();
                setTimeout(() => {
                    saveState(shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc);
                }, 0);
            }, [closeFreeShape, saveState, shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc]),
            selectedShapeId,
            setSelectedShapeId,
            // Removed the deleteSelectedShape prop completely from here
            shapes,
            selectedColor,
            setColorTolerance,
            selectedColorRgbString,
            handleContiguousColorMatch: useCallback(async () => {
                await handleContiguousColorMatch();
                setTimeout(() => {
                    saveState(shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc);
                }, 0);
            }, [handleContiguousColorMatch, saveState, shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc]),
            handleGlobalColorMatch: useCallback(async () => {
                await handleGlobalColorMatch();
                setTimeout(() => {
                    saveState(shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc);
                }, 0);
            }, [handleGlobalColorMatch, saveState, shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc]),
            detectCorruption: useCallback(async () => {
                await detectCorruption();
                setTimeout(() => {
                    saveState(shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc);
                }, 0);
            }, [detectCorruption, saveState, shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc]),
            detectCorruptionFromMask: useCallback(async () => {
                await detectCorruptionFromMask();
                setTimeout(() => {
                    saveState(shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc); // Corrected this line
                }, 0);
            }, [detectCorruptionFromMask, saveState, shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc]),
            repairMethod,
            setRepairMethod,
            repairPixels: useCallback(async (method, description) => {
                await repairPixels(method, description);
                setTimeout(() => {
                    saveState(shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc);
                }, 0);
            }, [repairPixels, saveState, shapes, colorPickedMaskDataUrl, activeDisplayMaskSrc]),
            imageTypeDescription,
            setImageTypeDescription,
            onGenerateKeywords,
            colorTolerance,
        }
    };

    return <AppLayout {...appLayoutProps} />;
}

export default App;
